<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>README.rdoc</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      //<![CDATA[
        function popupCode(url) {
          window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
        }
        
        function toggleCode(id) {
          var code = document.getElementById(id)
        
          code.style.display = code.style.display != 'block' ? 'block' : 'none'
          return true
        }
        
        // Make codeblocks hidden by default
        document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
      //]]>
    </script>
  </head>
  <body class='page'>
    <div class='file' id='wrapper'>
      <div class='header'>
        <h1 class='name'>README.rdoc</h1>
        <div class='paths'>
          README.rdoc
        </div>
        <div class='last-update'>
          Last Update:
          <span class='datetime'>2015-08-12 08:07:37 -0700</span>
        </div>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <h1 id="label-Rodauth">Rodauth<span><a href="#label-Rodauth">&para;</a> <a href="#top">&uarr;</a></span></h1>
            
            <p>Rodauth is an authentication framework using <a
            href="../classes/Roda.html">Roda</a>, Sequel, and PostgreSQL.</p>
            
            <h2 id="label-Design+Goals">Design Goals<span><a href="#label-Design+Goals">&para;</a> <a href="#top">&uarr;</a></span></h2>
            <ul><li>
            <p>Security: Ship in a maximum security by default configuration</p>
            </li><li>
            <p>Simplicity: Allow for easy configuration via a DSL</p>
            </li><li>
            <p>Flexibility: Allow for easy overriding of any part of the framework</p>
            </li></ul>
            
            <h2 id="label-Features">Features<span><a href="#label-Features">&para;</a> <a href="#top">&uarr;</a></span></h2>
            <ul><li>
            <p>Login</p>
            </li><li>
            <p>Logout</p>
            </li><li>
            <p>Change Password</p>
            </li><li>
            <p>Change Login</p>
            </li><li>
            <p>Reset Password</p>
            </li><li>
            <p>Create Account</p>
            </li><li>
            <p>Close Account</p>
            </li><li>
            <p>Verify Account</p>
            </li><li>
            <p>Remember (Autologin via token)</p>
            </li><li>
            <p>Lockout (Bruteforce protection)</p>
            </li></ul>
            
            <h2 id="label-Resources">Resources<span><a href="#label-Resources">&para;</a> <a href="#top">&uarr;</a></span></h2>
            <table class="rdoc-list note-list"><tbody><tr><td class='label'>RDoc </td><td>
            <p><a target="_top" href="http://rodauth.jeremyevans.net">rodauth.jeremyevans.net</a></p>
            </td></tr><tr><td class='label'>Demo Site </td><td>
            <p><a
            href="http://rodauth-demo.jeremyevans.net">rodauth-demo.jeremyevans.net</a></p>
            </td></tr><tr><td class='label'>Source </td><td>
            <p><a
            href="http://github.com/jeremyevans/rodauth">github.com/jeremyevans/rodauth</a></p>
            </td></tr><tr><td class='label'>Bugs </td><td>
            <p><a
            href="http://github.com/jeremyevans/rodauth/issues">github.com/jeremyevans/rodauth/issues</a></p>
            </td></tr></tbody></table>
            
            <h2 id="label-Security">Security<span><a href="#label-Security">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <h3 id="label-Passwords">Passwords<span><a href="#label-Passwords">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>Passwords are hashed using bcrypt, and the password hashes are kept in a
            separate table from the accounts table, with a foreign key referencing the
            accounts table.  A PostgreSQL function is added to check the password for a
            given application account matches.</p>
            
            <p>A separate database account owns the table containing the password hashes,
            which the application database account cannot access. The application
            database account has the ability to execute the function to check the
            password, but not the ability to access the password hashes directly,
            making it much more difficult for an attacker to access the password hashes
            even if they are able to exploit an SQL injection or remote code execution
            vulnerability in the application.  Even if an attacker was able to exploit
            a vulnerability in the application, they would only be to check if a
            specific password matches for a given user, which is the same access an
            attacker would have anyway if they just tried to login.</p>
            
            <p>While the application database account is not be able to read password
            hashes, it is still be able to insert password hashes, update passwords
            hashes, and delete password hashes, so the additional security is not that
            painful.</p>
            
            <p>The reason for extra security in regards to password hashes stems from the
            fact that people tend to reuse passwords, so a compromise of one site can
            result in account access on other sites, making password hash storage of
            critical importance even if the other data stored is not that important.</p>
            
            <p>If you are storing other important information in your database, you should
            consider using a similar approach in other areas (or all areas) of your
            application.</p>
            
            <p>Rodauth can still be used if you are using a more convential approach of
            storing the password hash in a column in the same table, with a single
            configuration setting.</p>
            
            <h3 id="label-Tokens">Tokens<span><a href="#label-Tokens">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>Account verification, password resets, remember, and lockout tokens all use
            a similar approach.  They all provide a token, in the format
            “account-id_long-random-string”.  By including the id of the account in the
            token, an attacker can only attempt to bruteforce the token for a single
            account, instead of being able to bruteforce tokens for all accounts at
            once (which would be possible if the token was just a random string).</p>
            
            <p>There is a maximum of 1 token per account for each of these features at a
            time. This prevents attackers from creating an arbitrary number of requests
            in order to make bruteforcing easier.</p>
            
            <h2 id="label-Database+Setup">Database Setup<span><a href="#label-Database+Setup">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>In order to get full advantages of Rodauth&#39;s security design, multiple
            database accounts are involved:</p>
            
            <p>1) database superuser account (usually postgres) 2) application database
            account 3) secondary database account</p>
            
            <p>The database superuser account is used to load extensions related to the
            database.  The application should never be run using the database superuser
            account.</p>
            
            <p>Note that there is not a simple way to use multiple database accounts in
            the same PostgreSQL database on Heroku.  You can still use Rodauth on
            Heroku, it just won&#39;t have the same security benefits.  That&#39;s not
            to say it is insecure, just that it drops the security level for password
            hash storage to the same level as other common authentication solutions.</p>
            
            <h3 id="label-Load+extensions">Load extensions<span><a href="#label-Load+extensions">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>If you want to use the login features for Rodauth, you need to load the
            pgcrypto extension with the database superuser account, and load the citext
            extension if you want to support case insensitive logins.</p>
            
            <p>Example:</p>
            
            <pre>echo &quot;CREATE EXTENSION pgcrypto&quot; | psql -U postgres $database_name&#x000A;echo &quot;CREATE EXTENSION citext&quot; | psql -U postgres $database_name</pre>
            
            <p>Note that on Heroku, both of these extensions can be loaded using a
            standard database account.</p>
            
            <h3 id="label-Create+database+accounts">Create database accounts<span><a href="#label-Create+database+accounts">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>If you are currently running your application using the database superuser
            account, the first thing you need to do is to create a database account for
            the application.  It&#39;s often best to name this account the same as the
            database name.</p>
            
            <p>You should also create a second database account which will own the
            password hash table.</p>
            
            <p>Example:</p>
            
            <pre>createuser -U postgres $database_name&#x000A;createuser -U postgres $database_name_password_hashes</pre>
            
            <p>Note that if the database superuser account owns all of the items in the
            database, you&#39;ll need to change the ownership to the database account
            you just created.  See <a
            href="https://gist.github.com/jeremyevans/8483320">gist.github.com/jeremyevans/8483320</a>
            for a way to do that.</p>
            
            <h3 id="label-Create+tables">Create tables<span><a href="#label-Create+tables">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>Because two different database accounts are used, two different migrations
            are required, one for each database account.  Here are example migrations.
            You can modify them to add support for additional columns, or remove tables
            or columns related to features that you don&#39;t need.</p>
            
            <p>First migration, run using the application database account:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">migration</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">up</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-comment"># Used by the account verification and close account features</span>&#x000A;    <span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">account_statuses</span>) <span class="ruby-keyword">do</span>&#x000A;      <span class="ruby-constant">Integer</span> :<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">primary_key=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>&#x000A;      <span class="ruby-constant">String</span> :<span class="ruby-identifier">name</span>, :<span class="ruby-identifier">null=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">false</span>, :<span class="ruby-identifier">unique=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-identifier">from</span>(:<span class="ruby-identifier">account_statuses</span>).<span class="ruby-identifier">import</span>([:<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">name</span>], [[<span class="ruby-value">1</span>, <span class="ruby-string">&#39;Unverified&#39;</span>], [<span class="ruby-value">2</span>, <span class="ruby-string">&#39;Verified&#39;</span>], [<span class="ruby-value">3</span>, <span class="ruby-string">&#39;Closed&#39;</span>]])&#x000A;&#x000A;    <span class="ruby-comment"># Used by the create account, account verification,</span>&#x000A;    <span class="ruby-comment"># and close account features.</span>&#x000A;    <span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">accounts</span>) <span class="ruby-keyword">do</span>&#x000A;      <span class="ruby-identifier">primary_key</span> :<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">type=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">Bignum</span>&#x000A;      <span class="ruby-identifier">foreign_key</span> :<span class="ruby-identifier">status_id</span>, :<span class="ruby-identifier">account_statuses</span>, :<span class="ruby-identifier">null=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">false</span>, :<span class="ruby-identifier">default=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>&#x000A;      <span class="ruby-identifier">citext</span> :<span class="ruby-identifier">email</span>, :<span class="ruby-identifier">null=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">false</span>&#x000A;&#x000A;      <span class="ruby-identifier">constraint</span> :<span class="ruby-identifier">valid_email</span>, :<span class="ruby-identifier">email=</span><span class="ruby-operator">&gt;</span><span class="ruby-regexp">/^[^,;@ \r\n]+@[^,@; \r\n]+\.[^,@; \r\n]+$/</span>&#x000A;      <span class="ruby-identifier">index</span> :<span class="ruby-identifier">email</span>, :<span class="ruby-identifier">unique=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>, :<span class="ruby-identifier">where=</span><span class="ruby-operator">&gt;</span>{:<span class="ruby-identifier">status_id=</span><span class="ruby-operator">&gt;</span>[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>]}&#x000A;    <span class="ruby-keyword">end</span>&#x000A;&#x000A;    <span class="ruby-comment"># Used by the password reset feature</span>&#x000A;    <span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">account_password_reset_keys</span>) <span class="ruby-keyword">do</span>&#x000A;      <span class="ruby-identifier">foreign_key</span> :<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">accounts</span>, :<span class="ruby-identifier">primary_key=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>, :<span class="ruby-identifier">type=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">Bignum</span>&#x000A;      <span class="ruby-constant">String</span> :<span class="ruby-identifier">key</span>, :<span class="ruby-identifier">null=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">false</span>&#x000A;      <span class="ruby-constant">DateTime</span> :<span class="ruby-identifier">deadline</span>, :<span class="ruby-identifier">null=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">false</span>, :<span class="ruby-identifier">default=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">lit</span>(<span class="ruby-string">&quot;CURRENT_TIMESTAMP + &#39;1 day&#39;&quot;</span>)&#x000A;    <span class="ruby-keyword">end</span>&#x000A;&#x000A;    <span class="ruby-comment"># Used by the account verification feature</span>&#x000A;    <span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">account_verification_keys</span>) <span class="ruby-keyword">do</span>&#x000A;      <span class="ruby-identifier">foreign_key</span> :<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">accounts</span>, :<span class="ruby-identifier">primary_key=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>, :<span class="ruby-identifier">type=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">Bignum</span>&#x000A;      <span class="ruby-constant">String</span> :<span class="ruby-identifier">key</span>, :<span class="ruby-identifier">null=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">false</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;&#x000A;    <span class="ruby-comment"># Used by the remember me feature</span>&#x000A;    <span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">account_remember_keys</span>) <span class="ruby-keyword">do</span>&#x000A;      <span class="ruby-identifier">foreign_key</span> :<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">accounts</span>, :<span class="ruby-identifier">primary_key=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>, :<span class="ruby-identifier">type=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">Bignum</span>&#x000A;      <span class="ruby-constant">String</span> :<span class="ruby-identifier">key</span>, :<span class="ruby-identifier">null=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">false</span>&#x000A;      <span class="ruby-constant">DateTime</span> :<span class="ruby-identifier">deadline</span>, :<span class="ruby-identifier">null=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">false</span>, :<span class="ruby-identifier">default=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">lit</span>(<span class="ruby-string">&quot;CURRENT_TIMESTAMP + &#39;2 weeks&#39;&quot;</span>)&#x000A;    <span class="ruby-keyword">end</span>&#x000A;&#x000A;    <span class="ruby-comment"># Used by the lockout feature</span>&#x000A;    <span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">account_login_failures</span>) <span class="ruby-keyword">do</span>&#x000A;      <span class="ruby-identifier">foreign_key</span> :<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">accounts</span>, :<span class="ruby-identifier">primary_key=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>, :<span class="ruby-identifier">type=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">Bignum</span>&#x000A;      <span class="ruby-constant">Integer</span> :<span class="ruby-identifier">number</span>, :<span class="ruby-identifier">null=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">false</span>, :<span class="ruby-identifier">default=</span><span class="ruby-operator">&gt;</span><span class="ruby-value">1</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">account_lockouts</span>) <span class="ruby-keyword">do</span>&#x000A;      <span class="ruby-identifier">foreign_key</span> :<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">accounts</span>, :<span class="ruby-identifier">primary_key=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>, :<span class="ruby-identifier">type=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">Bignum</span>&#x000A;      <span class="ruby-constant">String</span> :<span class="ruby-identifier">key</span>, :<span class="ruby-identifier">null=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">false</span>&#x000A;      <span class="ruby-constant">DateTime</span> :<span class="ruby-identifier">deadline</span>, :<span class="ruby-identifier">null=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">false</span>, :<span class="ruby-identifier">default=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">lit</span>(<span class="ruby-string">&quot;CURRENT_TIMESTAMP + &#39;1 day&#39;&quot;</span>)&#x000A;    <span class="ruby-keyword">end</span>&#x000A;&#x000A;    <span class="ruby-comment"># Grant password user access to reference accounts</span>&#x000A;    <span class="ruby-identifier">pw_user</span> = <span class="ruby-identifier">get</span>{<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">lit</span>(<span class="ruby-string">&#39;current_user&#39;</span>)} <span class="ruby-operator">+</span> <span class="ruby-string">&#39;_password&#39;</span>&#x000A;    <span class="ruby-identifier">run</span> <span class="ruby-node">&quot;GRANT REFERENCES ON accounts TO #{pw_user}&quot;</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-identifier">down</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-identifier">drop_table</span>(:<span class="ruby-identifier">account_lockouts</span>, :<span class="ruby-identifier">account_login_failures</span>, :<span class="ruby-identifier">account_remember_keys</span>,&#x000A;      :<span class="ruby-identifier">account_verification_keys</span>, :<span class="ruby-identifier">account_password_reset_keys</span>, :<span class="ruby-identifier">accounts</span>, :<span class="ruby-identifier">account_statuses</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Second migration, run using the secondary database account:</p>
            
            <pre class="ruby"><span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">migration</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">up</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-comment"># Used by the login and change password features</span>&#x000A;    <span class="ruby-identifier">create_table</span>(:<span class="ruby-identifier">account_password_hashes</span>) <span class="ruby-keyword">do</span>&#x000A;      <span class="ruby-identifier">foreign_key</span> :<span class="ruby-identifier">id</span>, :<span class="ruby-identifier">accounts</span>, :<span class="ruby-identifier">primary_key=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">true</span>, :<span class="ruby-identifier">type=</span><span class="ruby-operator">&gt;</span><span class="ruby-constant">Bignum</span>&#x000A;      <span class="ruby-constant">String</span> :<span class="ruby-identifier">password_hash</span>, :<span class="ruby-identifier">null=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">false</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;&#x000A;    <span class="ruby-comment"># Function used to check if a password is valid.  Takes the related account id</span>&#x000A;    <span class="ruby-comment"># and unencrypted password, checks if password matches password hash.</span>&#x000A;    <span class="ruby-identifier">run</span> <span class="ruby-value">&lt;&lt;END&#x000A;CREATE OR REPLACE FUNCTION account_valid_password(account_id int8, password text) RETURNS boolean AS $$&#x000A;DECLARE valid boolean;&#x000A;BEGIN&#x000A;SELECT password_hash = crypt($2, password_hash) INTO valid &#x000A;FROM account_password_hashes&#x000A;WHERE account_id = id;&#x000A;RETURN valid;&#x000A;END;&#x000A;$$ LANGUAGE plpgsql&#x000A;SECURITY DEFINER&#x000A;SET search_path = public, pg_temp;&#x000A;END</span>&#x000A;&#x000A;    <span class="ruby-comment"># Restrict access to the password hash table</span>&#x000A;    <span class="ruby-identifier">app_user</span> = <span class="ruby-identifier">get</span>{<span class="ruby-constant">Sequel</span>.<span class="ruby-identifier">lit</span>(<span class="ruby-string">&#39;current_user&#39;</span>)}.<span class="ruby-identifier">sub</span>(<span class="ruby-regexp">/_password\z/</span>, <span class="ruby-string">&#39;&#39;</span>)&#x000A;    <span class="ruby-identifier">run</span> <span class="ruby-string">&quot;REVOKE ALL ON account_password_hashes FROM public&quot;</span>&#x000A;    <span class="ruby-identifier">run</span> <span class="ruby-string">&quot;REVOKE ALL ON FUNCTION account_valid_password(int8, text) FROM public&quot;</span>&#x000A;    <span class="ruby-identifier">run</span> <span class="ruby-node">&quot;GRANT INSERT, UPDATE, DELETE ON account_password_hashes TO #{app_user}&quot;</span>&#x000A;    <span class="ruby-identifier">run</span> <span class="ruby-node">&quot;GRANT SELECT(id) ON account_password_hashes TO #{app_user}&quot;</span>&#x000A;    <span class="ruby-identifier">run</span> <span class="ruby-node">&quot;GRANT EXECUTE ON FUNCTION account_valid_password(int8, text) TO #{app_user}&quot;</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-identifier">down</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-identifier">run</span> <span class="ruby-string">&quot;DROP FUNCTION account_valid_password(int8, text)&quot;</span>&#x000A;    <span class="ruby-identifier">drop_table</span>(:<span class="ruby-identifier">account_password_hashes</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>If you are using a non-PostgreSQL database or cannot use multiple user
            accounts, just combine the two migrations into a single migration and
            exclude the GRANT/REVOKE statements.</p>
            
            <p>One thing to notice in the above migrations is that Rodauth uses additional
            tables for additional features, instead of additional columns in a single
            table.</p>
            
            <h2 id="label-Usage">Usage<span><a href="#label-Usage">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <h3 id="label-Basic+Usage">Basic Usage<span><a href="#label-Basic+Usage">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>Rodauth is a <a href="../classes/Roda.html">Roda</a> plugin and loaded the
            same way other <a href="../classes/Roda.html">Roda</a> plugins are loaded:</p>
            
            <pre class="ruby"><span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">rodauth</span> <span class="ruby-keyword">do</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>The block passed to the plugin call uses the Rodauth configuration DSL. The
            one configuration method that should always be used is enable, which
            chooses which features you would like to load:</p>
            
            <pre class="ruby"><span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">rodauth</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">enable</span> :<span class="ruby-identifier">login</span>, :<span class="ruby-identifier">logout</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Once features are loaded, you can use any of the configuration methods
            supported by the features.  There are three types of configuration methods.
            The first type are called auth methods, and they take a block, and
            overrides the default method that Rodauth uses.  Inside the block, you can
            call super if you want to get the default behavior.  For example, if you
            want to add additional logging when a user logs in:</p>
            
            <pre class="ruby"><span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">rodauth</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">enable</span> :<span class="ruby-identifier">login</span>, :<span class="ruby-identifier">logout</span>&#x000A;  <span class="ruby-identifier">after_login</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-identifier">logger</span>.<span class="ruby-identifier">info</span> <span class="ruby-node">&quot;#{account.email} logged in!&quot;</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Inside the block, you are in the context of the Rodauth::Auth instance
            related to the request.  This object has access to everything related to
            the request via methods:</p>
            <table class="rdoc-list note-list"><tbody><tr><td class='label'>request </td><td>
            <p>RodaRequest instance</p>
            </td></tr><tr><td class='label'>response </td><td>
            <p>RodaResponse instance</p>
            </td></tr><tr><td class='label'>scope </td><td>
            <p><a href="../classes/Roda.html">Roda</a> instance</p>
            </td></tr><tr><td class='label'>session </td><td>
            <p>session hash</p>
            </td></tr><tr><td class='label'>flash </td><td>
            <p>flash message hash</p>
            </td></tr><tr><td class='label'>account </td><td>
            <p>account model instance (if set by an earlier Rodauth method)</p>
            </td></tr></tbody></table>
            
            <p>So if you want to log the IP address for the user during login:</p>
            
            <pre class="ruby"><span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">rodauth</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">enable</span> :<span class="ruby-identifier">login</span>, :<span class="ruby-identifier">logout</span>&#x000A;  <span class="ruby-identifier">after_login</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-identifier">logger</span>.<span class="ruby-identifier">info</span> <span class="ruby-node">&quot;#{account.email} logged in from #{request.ip}&quot;</span>&#x000A;    <span class="ruby-keyword">super</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>The second type of configuration methods are called auth value methods. 
            They are similar to auth methods, but instead of just accepting a block,
            they can optionally accept a single argument without a block, which will be
            treated as a block that just returns that value.  For example, the
            account_model method sets the model class to use for the account, so to
            override it, you can call the method with another class:</p>
            
            <pre class="ruby"><span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">rodauth</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">enable</span> :<span class="ruby-identifier">login</span>, :<span class="ruby-identifier">logout</span>&#x000A;  <span class="ruby-identifier">account_model</span> <span class="ruby-constant">User</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>The third type of configuration methods are called auth block methods, and
            there are three of them per feature, one for handling the route itself, one
            for handling just the GET route, and one for handling just the POST route. 
            For the login feature, login_route_block would set the routing block to use
            if the login route matches, login_get_block would set the routing block to
            use if the login route matches and it is a GET request, and
            login_post_block would set the routing block to use if the login route
            matches and it is a POST request.  As auth block methods specify the route
            blocks, they are executed in the context of the <a
            href="../classes/Roda.html">Roda</a> instance, and are passed two
            arguments, the first being the RodaRequest instance, and the second being
            the Rodauth::Auth instance. For example, if you wanted to override how a
            POST request to the login route is handled:</p>
            
            <pre class="ruby"><span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">rodauth</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">enable</span> :<span class="ruby-identifier">login</span>&#x000A;  <span class="ruby-identifier">login_post_route</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span>, <span class="ruby-identifier">auth</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-comment"># ...</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>By allowing every configuration method to take a block, Rodauth should be
            flexible enough to integrate into most legacy authentication systems.</p>
            
            <h3 id="label-Feature+Documentation">Feature Documentation<span><a href="#label-Feature+Documentation">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>The options/methods for the supported features are listed on a separate
            page per feature.  If these links are not active, please view the
            appropriate file in the doc directory.</p>
            <ul><li>
            <p><a href="doc/base_rdoc.html">Base</a> (this feature is autoloaded)</p>
            </li><li>
            <p><a href="doc/login_rdoc.html">Login</a></p>
            </li><li>
            <p><a href="doc/logout_rdoc.html">Logout</a></p>
            </li><li>
            <p><a href="doc/change_password_rdoc.html">Change Password</a></p>
            </li><li>
            <p><a href="doc/change_login_rdoc.html">Change Login</a></p>
            </li><li>
            <p><a href="doc/reset_password_rdoc.html">Reset Password</a></p>
            </li><li>
            <p><a href="doc/create_account_rdoc.html">Create Account</a></p>
            </li><li>
            <p><a href="doc/close_account_rdoc.html">Close Account</a></p>
            </li><li>
            <p><a href="doc/verify_account_rdoc.html">Verify Account</a></p>
            </li><li>
            <p><a href="doc/remember_rdoc.html">Remember</a></p>
            </li><li>
            <p><a href="doc/lockout_rdoc.html">Lockout</a></p>
            </li></ul>
            
            <p>Since the auth block methods work the same way for each of these features,
            they are not documented on the feature pages. Additionally, all features
            have a before auth method (e.g. before_login) that is called before either
            the GET or POST route blocks are handled.</p>
            
            <h3 id="label-With+Multiple+Configurations">With Multiple Configurations<span><a href="#label-With+Multiple+Configurations">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>Rodauth supports using multiple rodauth configurations in the same
            application.  You just need to load the plugin a second time, providing a
            name for any alternate configuration:</p>
            
            <pre class="ruby"><span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">rodauth</span> <span class="ruby-keyword">do</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">rodauth</span>, :<span class="ruby-identifier">name=</span><span class="ruby-operator">&gt;</span>:<span class="ruby-identifier">secondary</span> <span class="ruby-keyword">do</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Then in your routing code, any time you call rodauth, you can provide the
            name as an argument to use that configuration:</p>
            
            <pre class="ruby"><span class="ruby-identifier">route</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">on</span> <span class="ruby-string">&#39;secondary&#39;</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-identifier">r</span>.<span class="ruby-identifier">rodauth</span>(:<span class="ruby-identifier">secondary</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">rodauth</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h3 id="label-With+Other+Databases">With Other Databases<span><a href="#label-With+Other+Databases">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>You can use Rodauth with other databases besides PostgreSQL. Assuming you
            are storing the password hashes in the same table as the account
            information, you can just do:</p>
            
            <pre class="ruby"><span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">rodauth</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">account_password_hash_column</span> :<span class="ruby-identifier">password_hash</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>When this option is set, Rodauth will not use a database function to
            authenticate, it will do the check in ruby.  This feature can also be used
            if you are using PostgreSQL, but for legacy reasons are storing the
            password hashes in the same table as the account information.</p>
            
            <p>The Rodauth lockout feature also uses UPDATE RETURNING to update a row and
            return the new value, so if you are not using PostgreSQL and wish to use
            the lockout feature, you&#39;ll need to override the
            invalid_login_attempted method.</p>
            
            <h3 id="label-With+Other+Web+Frameworks">With Other Web Frameworks<span><a href="#label-With+Other+Web+Frameworks">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>You can use Rodauth even if your application does not use the <a
            href="../classes/Roda.html">Roda</a> web framework.  This is possible by
            adding a <a href="../classes/Roda.html">Roda</a> middleware that uses
            Rodauth:</p>
            
            <pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;roda&#39;</span>&#x000A;&#x000A;<span class="ruby-keyword">class</span> <span class="ruby-constant">RodauthApp</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">Roda</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">middleware</span>&#x000A;  <span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">rodauth</span>&#x000A;  <span class="ruby-identifier">route</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">r</span>.<span class="ruby-identifier">rodauth</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span>&#x000A;&#x000A;<span class="ruby-identifier">use</span> <span class="ruby-constant">RodauthApp</span></pre>
            
            <h3 id="label-Using+External+Features">Using External Features<span><a href="#label-Using+External+Features">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>The enable configuration method is able to load features external to
            Rodauth.  You need to place the external feature file where it can be
            required via roda/plugins/rodauth/feature_name. That file should use the
            following basic structure</p>
            
            <pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Roda</span>&#x000A;  <span class="ruby-keyword">module</span> <span class="ruby-constant">RodaPlugins</span>&#x000A;    <span class="ruby-keyword">module</span> <span class="ruby-constant">Rodauth</span>&#x000A;      <span class="ruby-comment"># :feature_name will be the argument given to enable to</span>&#x000A;      <span class="ruby-comment"># load the feature</span>&#x000A;      <span class="ruby-constant">FeatureName</span> = <span class="ruby-constant">Feature</span>.<span class="ruby-identifier">define</span>(:<span class="ruby-identifier">feature_name</span>) <span class="ruby-keyword">do</span>&#x000A;        <span class="ruby-identifier">auth_value_methods</span> <span class="ruby-comment"># one argument per auth value method</span>&#x000A;        <span class="ruby-identifier">auth_methods</span> <span class="ruby-comment"># one argument per auth method</span>&#x000A;&#x000A;        <span class="ruby-identifier">get_block</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span>, <span class="ruby-identifier">auth</span><span class="ruby-operator">|</span>&#x000A;          <span class="ruby-comment"># r is the RodaRequest instance</span>&#x000A;          <span class="ruby-comment"># auth is the Rodauth::Auth instance</span>&#x000A;          <span class="ruby-comment"># This block is evaluated in the scope of the Roda instance</span>&#x000A;          <span class="ruby-comment"># ...</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;&#x000A;        <span class="ruby-identifier">post_block</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span>, <span class="ruby-identifier">auth</span><span class="ruby-operator">|</span>&#x000A;          <span class="ruby-comment"># ...</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;&#x000A;        <span class="ruby-comment"># define the default behavior for the auth methods</span>&#x000A;        <span class="ruby-comment"># and auth value methods</span>&#x000A;        <span class="ruby-comment"># ...</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h2 id="label-Possible+Future+Directions">Possible Future Directions<span><a href="#label-Possible+Future+Directions">&para;</a> <a href="#top">&uarr;</a></span></h2>
            <ul><li>
            <p>OmniAuth support.  This is not something I plan to work on myself, but I
            will consider patches that add it.</p>
            </li></ul>
            
            <h2 id="label-Similar+Projects">Similar Projects<span><a href="#label-Similar+Projects">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>All of these are Rails-specific:</p>
            <ul><li>
            <p>Devise</p>
            </li><li>
            <p>Authlogic</p>
            </li><li>
            <p>Sorcery</p>
            </li></ul>
            
            <h2 id="label-Author">Author<span><a href="#label-Author">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>Jeremy Evans &lt;code@jeremyevans.net&gt;</p>
          </div>
          <div id='context'>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a target="docwin" href="http://github.com/mislav/hanna/tree/master"><strong>Hanna</strong> RDoc template</a>
    </div>
  </body>
</html>
